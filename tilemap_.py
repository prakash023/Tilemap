# -*- coding: utf-8 -*-
"""Copy of TileMap.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CxWJwWOu310H3lVHz77kwspgV5FWYSlh
"""

# Install necessary libraries
!pip install geopandas shapely pyproj fiona ipywidgets --quiet

# Imports
import geopandas as gpd
import matplotlib.pyplot as plt
from shapely.geometry import box, Polygon
import math
import os
from ipywidgets import FileUpload, Dropdown, Button, Output, RadioButtons, VBox
from IPython.display import display, clear_output
import ipywidgets as widgets

# Upload widget
upload = FileUpload(accept='.geojson', multiple=False)
label_col_selector = Dropdown(description='Label Column:')
tile_shape_selector = RadioButtons(options=['rectangle', 'hexagon'], description='Tile Shape:')
generate_button = Button(description='Generate Tiles', button_style='success')
export_button = Button(description='Export GeoJSON', button_style='info')
#output = Output()
output = widgets.Output()


# Global variables for access across functions
bezirke = None
snapped_grid = None
final_grid = None
output_filename = "output_tiles.geojson"
na=None

def handle_upload(change):
    global bezirke
    global na
    if upload.value:
        for filename, fileinfo in upload.value.items():
            with open(filename, 'wb') as f:
                f.write(fileinfo['content'])

            na=filename
            bezirke = gpd.read_file(filename)
            bezirke = bezirke.to_crs(epsg=32633)

            # Populate dropdown with column names
            label_col_selector.options = list(bezirke.columns)

upload.observe(handle_upload, names='value')

def calculate_optimal_tile_size(bounds, target_count):
    minx, miny, maxx, maxy = bounds
    area = (maxx - minx) * (maxy - miny)
    tile_area = area / target_count
    size = math.sqrt(tile_area)
    return size, size

def generate_tiles(b):
    global snapped_grid, final_grid, output_filename
    with output:
      clear_output(wait=True)
      export_button.disabled = True

      if bezirke is None:
          with output:
              print("❌ Bitte zuerst eine GeoJSON-Datei hochladen.")
          return

      nam = label_col_selector.value
      tile_shape = tile_shape_selector.value
      label_mode = 'name'

      bezirke["centroid"] = bezirke.geometry.centroid
      minx, miny, maxx, maxy = bezirke.total_bounds
      target_cells = len(bezirke)
      grid_width, grid_height = calculate_optimal_tile_size(bezirke.total_bounds, target_cells)

      grid = []
      while len(grid) != len(bezirke):
          if len(grid) < len(bezirke):
              grid_width *= 0.98
              grid_height *= 0.98
          else:
              grid_width *= 1.02
              grid_height *= 1.02

          grid_cells = []

          if tile_shape == "rectangle":
              x = minx
              while x < maxx:
                  y = miny
                  while y < maxy:
                      grid_cells.append(box(x, y, x + grid_width, y + grid_height))
                      y += grid_height
                  x += grid_width

          elif tile_shape == "hexagon":
              hex_height = grid_height
              hex_width = math.sqrt(3) / 2 * hex_height
              y = miny
              row = 0
              while y < maxy + hex_height:
                  x = minx - (row % 2) * (hex_width / 2)
                  while x < maxx + hex_width:
                      angles = [math.radians(a) for a in range(-30, 330, 60)]
                      points = [(x + (hex_height / 2) * math.cos(a), y + (hex_height / 2) * math.sin(a)) for a in angles]
                      grid_cells.append(Polygon(points))
                      x += hex_width
                  y += hex_height * 0.75
                  row += 1
          else:
              raise ValueError("Ungültiger tile_shape")

          grid = gpd.GeoDataFrame({'geometry': grid_cells}, crs=bezirke.crs)
          region_union = bezirke.geometry.union_all()
          grid = grid[grid.intersects(region_union)].reset_index(drop=True)
          grid["grid_centroid"] = grid.geometry.centroid

          if len(grid) >= len(bezirke):
              break

      assigned_geoms = []
      assigned_labels = []
      available_grids = grid.copy()

      for idx, row in bezirke.iterrows():
          centroid = row["centroid"]
          available_grids["distance"] = available_grids["grid_centroid"].distance(centroid)
          candidate_idx = available_grids["distance"].idxmin()
          assigned_geoms.append(available_grids.loc[candidate_idx].geometry)
          assigned_labels.append(row[nam])
          available_grids = available_grids.drop(index=candidate_idx)

      snapped_grid = gpd.GeoDataFrame({
          "geometry": assigned_geoms,
          nam: assigned_labels
      }, crs=bezirke.crs)

      # Combine with original attributes
      final_grid = snapped_grid.copy()
      try:
          final_grid = snapped_grid.drop(columns=[nam]).copy()
      except:
          pass
      attr = bezirke.drop(columns=['geometry', 'centroid']).reset_index(drop=True)
      final_grid = final_grid.join(attr)
      tile_size_str = f"{int(grid_width)}x{int(grid_height)}"
      output_filename = f"{na}_Tilemap_{tile_size_str}_{tile_shape}_{bezirke.crs}.geojson"

      #output_filename = f"generated_tilemap_{tile_shape}.geojson"
      export_button.disabled = False  # Enable export after generation
      with output:
          print("Kacheln erfolgreich generiert.")
          print("Gesamtzahl der Polygons:", len(bezirke))
          print("Gesamtzahl der Kacheln:", len(grid))
          print("Zugeordnete Kacheln aus dem Originalraster:", len(snapped_grid))



      # Plotting
      fig, ax = plt.subplots(figsize=(12, 8))
      snapped_grid.boundary.plot(ax=ax, edgecolor='blue', linewidth=0.8)
      bezirke.boundary.plot(ax=ax, edgecolor='black')
      for idx, row in snapped_grid.iterrows():
          centroid = row.geometry.centroid
          ax.text(centroid.x, centroid.y, str(row[nam])[:10], fontsize=8, ha='center', color='darkred')
      ax.set_title("Zugeordnete Kacheln")
      ax.set_aspect('equal')
      plt.tight_layout()
      plt.show()

def export_geojson(b):
    if final_grid is None:
        with output:
            print("Keine Tilemap vorhanden. Bitte zuerst 'Generate Tiles' klicken.")
        return

    final_grid.to_file(output_filename, driver='GeoJSON')
    with output:
        print(f"Datei exportiert: {output_filename}")

generate_button.on_click(generate_tiles)
export_button.on_click(export_geojson)
display(VBox([upload, label_col_selector, tile_shape_selector, generate_button, export_button, output]))